# CPU

The programme is free-to-use for all kinds of developers.
### What does the project do
***
It is a processor simulation.

### Why is the project useful
***
Although many virtual processors have already been made, realization of your own processor is an interesting and challenging task
that helps to realize how complicated the machine is and allows to notice some details that could not be seen without it.


### Structure
***
This program consists of three main parts:

1. __Assembler__: it reads lines of code written in a source file, analyses code according to rules of my assembly language dialect
and if there are no mistakes transfers assembly code into bytecode in executable file that can be executed by processor.

2. __Processor__: it reads the file generated by assembler and executes it.

3. __Disassembler__: if executable file was created according to rules of my assembly language dialect, then disassembler reads commands
from executable and creates text file with commands which can be then transferred to executable via assembler.


### Brief architecture
***
This processor implementation includes (separately):

1. __four registers__: ax, bx, cx and dx
2. __array of RAM__, which can be used for storing large quantities of data
3. __program stack__, where values can be pushed and popped
4. __call stack__, which is responsible for call and ret instructions

As we can see, this implementation answers the convention of *the Harvard architecture*, which means that different parts of the processor
architecture are separated. In real life it is more expensive and much less common than the *von Neumann architecture*, but its main
advantage is that the processor becomes more reliable: e.g., it is now impossible to spoil the return address by data stored in stack
just because this data now contains in another stack.

### Commands
***
This section describes all commands that are implemented in my dialect of assembly language.

1. *Exit commands*
   
   - __hlt__: exits the program. This command __must__ be at the end of any written assembler program, in other case its correct execution
              is not guaranteed, undefined behaviour might be caused.

2. *Stack commands*
   - __push__: puts value onto the stack. Argument types:
       + push const (pushes const value)
       + push register (pushes value in register)
       + push [const] (pushes value from place in RAM indicated by const value)
       + push [register] (pushes value from place in RAM indicated by value in register)
       + push [register + const] (pushes value from place in RAM indicated by sum value in register + const value)

   - __pop__: get value from stack __IMPORTANT!__ value is not copied but removed from stack. Argument types:
       + pop  (just pops value)
       + pop register (pops value to register)
       + pop [register] (pops value to place in RAM indicated by value in register
       + pop [register + const] (pops value to place in RAM indicated by sum value in register + const value)
   
   -__dump__: dumps information about processor's current condition: registers, stack and call stack content and parameters
              and position of instruction pointer (which is a bias of currently executed command in bytecode in executable file).
   

### How can I help
***
I explicitly welcome any outside contributors. Use my mail: _ilichev.kv@phystech.edu_.

__A strong request__:
* Do not break the codestyle
* Do not destroy previous functionality with additions

### Where to ask questions
***
Use the mail mentioned earlier.
